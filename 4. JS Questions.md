## JavaScript Interview Questions

### 1.Can JavaScript run only in browser?

No, JavaScript is not limited to running only in browsers. Initially designed as a scripting language for web browsers, JavaScript has evolved significantly over the years and can now be executed in various environments outside of web browsers. This expansion has been largely facilitated by the development of Node.js and other similar technologies.

<details>
<summary>Key Points:</summary>

- **Browser Environment**: Traditionally, JavaScript was primarily used within web browsers to make websites interactive and dynamic.
- **Node.js**: A runtime environment that allows JavaScript to be run on the server side.
- **Other Platforms**: JavaScript can also run in environments like Deno, Electron, mobile app development frameworks (e.g., React Native, NativeScript), and IoT devices.
- **Cloud Services and APIs**: JavaScript can be used to build and interact with cloud-based services and APIs, leveraging serverless computing platforms.

</details>

<details>
    <summary>Summary</summary>
    JavaScript is not confined to the browser. It can also run on server-side (via Node.js), in mobile app development, IoT devices, and cloud services, thanks to its versatility and the development of various platforms and frameworks that support JavaScript outside the web browser context.
</details>

### 2. What software or hardware does a browser have that enables it to understand JavaScript?

Browsers are equipped with software components known as **JavaScript engines** (or interpreters) that enable them to understand and execute JavaScript code. These engines are complex pieces of software responsible for parsing, compiling, and executing JavaScript, allowing for dynamic interactions within web pages.

<details>
<summary>Key JavaScript Engines:</summary>

- **V8**: Used by Google Chrome and Node.js, known for high performance by compiling JavaScript directly into native machine code.
- **SpiderMonkey**: The engine used by Mozilla Firefox, the first JavaScript engine ever written.
- **JavaScriptCore (Nitro)**: Used by Safari, part of the WebKit project, known for its efficiency.
- **Chakra**: Formerly used by Microsoft Edge, now replaced by the V8 engine in the latest versions.

</details>

<details>
<summary>How JavaScript Engines Work:</summary>

1. **Parsing**: JavaScript code is parsed into an Abstract Syntax Tree (AST).
2. **Compilation**: Uses Just-In-Time (JIT) compilation for better performance.
3. **Execution**: The compiled code is executed by the machine.
4. **Optimization**: Performs optimizations like inline caching and dead code elimination.

</details>

<details>
    <summary>Additional Browser Capabilities:</summary>
    
- **Web APIs**: Browsers provide Web APIs for tasks not part of the core JavaScript language, such as DOM manipulation and making HTTP requests.
- **Event Loop and Concurrency Model**: Support non-blocking operations and maintain the responsiveness of web pages through an event loop and concurrency model.

</details>

<details>
    <summary>Summary</summary>
    Browsers use JavaScript engines to parse, compile, and execute JavaScript code. Each major browser has its own engine, such as V8 for Chrome and SpiderMonkey for Firefox. These engines, along with Web APIs and an event loop model, enable browsers to run JavaScript code efficiently and securely, facilitating dynamic content and interactive web applications.
</details>

3. Where all can javascript run?

### 4. What comes under JavaScript runtime?

<details>
<summary>Answer</summary>

The JavaScript runtime encompasses all the components necessary to execute JavaScript code, especially outside the browser environment, such as with Node.js or Deno. A typical JavaScript runtime includes:

- **JavaScript Engine**: This is the core component that parses, compiles, and executes JavaScript code. Examples include V8 (used by Chrome and Node.js), SpiderMonkey (used by Firefox), and JavaScriptCore (used by Safari).

- **Event Loop**: A programming construct that waits for and dispatches events or messages in a program. It's crucial for JavaScript's non-blocking, event-driven nature, allowing for asynchronous operations.

- **Web APIs/Node APIs**: In browser environments, Web APIs are provided by the browser, offering functionalities that JavaScript can't directly access, like the DOM, timers, fetch for HTTP requests, etc. In Node.js, similar capabilities come through built-in modules and APIs for file system operations, HTTP requests, and more, tailored for server-side or development environments.

- **Callback Queue**: JavaScript uses a callback queue to manage the execution order of asynchronous operations. When an asynchronous operation completes, its callback is added to the queue and then executed by the main thread when the call stack is empty.

- **Call Stack**: This is where the runtime keeps track of all the function calls in your program. When a function is executed, it's pushed onto the call stack. When the function returns, it's popped off the stack. This keeps track of where the program is in its execution flow.

Together, these components work to provide a comprehensive environment for executing JavaScript code efficiently, handling asynchronous operations, managing events, and interfacing with external APIs and resources.

</details>
<details>
    <summary>Summary</summary>

    The JavaScript runtime includes the JavaScript engine for code execution, an event loop for asynchronous operations, Web APIs (in browsers) or Node APIs (in Node.js) for accessing external functionalities, a callback queue for managing the execution order of asynchronous callbacks, and a call stack for tracking function calls. These components collaborate to execute JavaScript code, handle events, and provide a non-blocking, event-driven programming environment.

</details>

### 5. How does JavaScript achieve asynchronicity? Is it JS or the browser?

JavaScript achieves asynchronicity primarily through its event loop and callback mechanism, along with Promises and async/await syntax, which are built into the language. The ability to execute asynchronous operations, such as fetching data over a network or reading files in Node.js, is not a direct feature of JavaScript itself but rather is provided by the environment in which JavaScript runs (i.e., the browser or Node.js).

<details>
<summary>The Event Loop:</summary>

The event loop is a fundamental part of the JavaScript runtime environment that allows JavaScript to perform non-blocking operations despite being single-threaded. It works by executing code, collecting and processing events, and executing queued sub-tasks.

</details>

<details>
<summary>Callbacks:</summary>

Initially, JavaScript handled asynchronous operations through callbacks, where a function is passed as an argument to another function to be executed once an operation completes. However, this could lead to callback hell, making code nested and difficult to read.

</details>

<details>
<summary>Promises:</summary>

Promises were introduced to address the challenges of callback hell, representing the eventual completion (or failure) of an asynchronous operation and allowing for more manageable asynchronous code.

</details>

<details>
<summary>Async/Await:</summary>

Async/await syntax, building on Promises, simplifies the chaining of Promises and makes asynchronous code easier to read and write by allowing asynchronous code to look and behave more like synchronous code.

</details>

<details>
    <summary>Is It JS or the Browser?</summary>
    While the JavaScript language defines the syntax and mechanisms for handling asynchronicity (such as Promises and async/await), the actual implementation of asynchronous operations is provided by the host environment (browser or Node.js), which is responsible for executing JavaScript code and providing APIs for asynchronous tasks.
</details>

<details>
    <summary>Summary</summary>
    JavaScript achieves asynchronicity through its event loop, callbacks, Promises, and async/await syntax, but the ability to perform asynchronous tasks relies on the APIs and runtime environment (such as a browser or Node.js) where JavaScript is executed.
</details>

### 6. What happens in the JavaScript engine of a browser when a JS file gets executed?

When discussing JavaScript execution in a browser, it's crucial to understand that JavaScript runs in the browser's JavaScript engine, not in a Java Runtime Environment (JRE). Here's the process when a JavaScript file gets executed in a browser:

<details>
<summary>Loading the JS File:</summary>

The browser loads the JavaScript file from the server or local cache through a `<script>` tag in an HTML document.

</details>

<details>
<summary>Parsing:</summary>

The JavaScript engine parses the loaded code to create an Abstract Syntax Tree (AST), checking the syntax for errors.

</details>

<details>
<summary>Compilation:</summary>

Many modern engines use Just-In-Time (JIT) compilation, converting the parsed code into bytecode or directly into machine code, optimizing performance.

</details>

<details>
<summary>Optimization:</summary>

The engine optimizes the compiled code on the fly, especially frequently used parts, to make them run faster.

</details>

<details>
<summary>Execution:</summary>

The compiled and optimized code is executed, with the engine handling memory allocation, garbage collection, and executing instructions.

</details>

<details>
<summary>Interaction with Web APIs:</summary>

JavaScript can call Web APIs provided by the browser to perform tasks like DOM manipulation and network requests. These are not part of JavaScript itself but are provided for JavaScript to use.

</details>

<details>
<summary>Event Loop and Asynchronous Execution:</summary>

The browser's event loop handles asynchronous operations, ensuring they do not block other scripts' execution by managing callbacks and the task queue.

</details>

<details>
    <summary>Summary</summary>
    The execution of a JavaScript file in a browser involves loading the script, parsing the code, compiling it to bytecode or machine code, optimizing the execution, and finally executing the code. This process is managed by the browser's JavaScript engine, which also handles memory management, asynchronous operations via the event loop, and interaction with Web APIs.
</details>

### 7. Data Types in JavaScript

JavaScript provides several data types to handle a variety of data in programs. These are broadly categorized into primitive types and object types.

<details>
<summary>Primitive Types:</summary>

1. **Number**: Represents both integer and floating-point numbers, e.g., `42`, `3.14`.
2. **String**: Represents textual data, e.g., `"Hello, world!"`, `'JavaScript'`.
3. **Boolean**: Represents a logical entity with two values: `true` and `false`.
4. **Undefined**: Indicates an uninitialized variable, having no value assigned.
5. **Null**: Represents the intentional absence of any object value.
6. **Symbol** (ES6): A unique and immutable primitive value, used as the key of an Object property.
7. **BigInt** (ES2020): Represents numbers larger than 2^53 - 1 with arbitrary precision.

</details>

<details>
<summary>Object Types:</summary>

- **Object**: Collections of properties, representing more complex entities.

</details>

<details>
<summary>Special Note on Arrays, Functions, and Dates:</summary>

- **Arrays**, **Functions**, and **Dates** are technically objects but are often treated as separate data types for practical purposes.
  - **Arrays** are used for ordered collections.
  - **Functions** are executable objects.
  - **Dates** represent dates and times.

</details>

<details>
<summary>Null and Undefined:</summary>

- `null` and `undefined` both represent the absence of a meaningful value, but with slightly different uses. `undefined` typically means a variable has been declared but not defined, while `null` is used to intentionally denote a null value.

</details>

<details>
    <summary>Summary</summary>
    JavaScript's dynamic typing means a variable's data type can change based on its assigned value. The language offers a mix of primitive and object types to handle various data needs efficiently.
</details>

### 8. `var` vs `let` vs `const`

In JavaScript, `var`, `let`, and `const` are used to declare variables, but they come with different implications in terms of scope, hoisting, and reassignment capabilities.

<details>
<summary>var</summary>

- **Scope**: Function scope or global scope if declared outside any function.
- **Hoisting**: Variables are hoisted to the top of their function or global scope but not initialized.
- **Reassignment**: Can be reassigned and redeclared within its scope.

</details>

<details>
<summary>let</summary>

- **Scope**: Block scope, meaning the variable is accessible only within the nearest enclosing block.
- **Hoisting**: Variables are hoisted to the top of their block scope but not initialized, leading to a ReferenceError if accessed before declaration.
- **Reassignment**: Can be reassigned but cannot be redeclared within the same scope.

</details>

<details>
<summary>const</summary>

- **Scope**: Block scope, similar to `let`.
- **Hoisting**: Hoisted to the top of their block scope but not initialized, leading to a ReferenceError if accessed before declaration.
- **Reassignment**: Cannot be reassigned or redeclared. Must be initialized at declaration. Note: `const` objects' properties can be modified.

</details>

<details>
    <summary>Summary and Best Practices</summary>
    
- **Use `var`** for variables with a required function or global scope (less common nowadays).
- **Use `let`** for variables that will change over time and are confined to a block.
- **Use `const`** for variables that should not change after initialization and are confined to a block.

Choosing `let` and `const` over `var` enhances code readability and minimizes unexpected behavior due to clearer scope and hoisting rules.

</details>

9. Namaste JS output questions.
10. function borrowing in JS - > call, apply & bind

    let objA = {
    name: "object A",
    say: function(greet) {
    alert(greet + ", " + this.name);
    }
    }

    objA.say("Hi"); // Displays: Hi, object A

    let objB = {
    name: "object B"
    }

---

    /* The objB doesn't have say() method, but it can borrow it from objA */
    objA.say.call(objB, "Hello");

    objA.say.apply(objB, ["Hello"]); // Displays: Hello, object B

    let newSay = objA.say.bind();
    newSay("Hello")

11. function currying in js
    Currying in JavaScript transforms a function with multiple arguments into a nested series of functions, each taking a single argument.
    Currying helps you avoid passing the same variable multiple times, and it helps you create a higher order function.

Case 2: add(1)(2)(3)â€¦(n)()

function add(a) {
return function(b){
if(b){
return add(a+b)
}
return a
}
} 13. Polyfil of map
Array.prototype.myMap = function(callbackFn) {
var arr = [];  
 for (var i = 0; i < this.length; i++) {
/_ call the callback function for every value of this array and push the returned value into our resulting array
_/
arr.push(callbackFn(this[i], i, this));
}
return arr;
}

12. How to add a new function to javascript array datatype.
    Array.prototype.myMap = () => {console.log('mymap called')}

13. Promise.all, Promise.race, Promise.allSettled.

14. Array.prototype.myReduce = function(fn, initial) {
    let values = this;

        values.forEach(item => {
            initial = initial !== undefined ? fn(initial, item) : item
        })

        return initial;

    }

14.1 Flatten an array:
Array.prototype.flatten = function () {
let flatArray = []
for (let index = 0; index < this.length; index++) {
const element = this[index];
if (Array.isArray(element)) {
flatArray = flatArray.concat(this.flatten.call(element))
} else {
flatArray.push(element)
}
}
return flatArray;
}
// function flatten
//const nestedArr = [[1], [[1, 4, [5, 3]], [1, 2, 3, 4]]] => [1, 1, 4, 5, 3, 1, 2, 3, 4]
const nestedArr = [[1], [[1, 4, [5, 3]], [1, 2, 3, [3, 4, [2, [22, [3, 4, 5, 6, 5, [2]]]]], 4]]]
const flat = nestedArr.flatten();
console.log(flat);

14.2 Counting unique elements in an array in JavaScript

        const arr = ["hi", "hello", "hi"];
        const countUnique = arr => {
        const counts = {};
        for (var i = 0; i < arr.length; i++) {
            counts[arr[i]] = 1 + (counts[arr[i]] || 0);
        };
        return counts;
        };
        console.log(countUnique(arr));

15. Memoization in javascript

const memoizedFunc = (fn) => {
const cache = {};
return (...args) => {
const argsToString = JSON.stringify(args);
if(argsToString in cache){
console.log('From cache', argsToString)
return cache[argsToString]
} else{
const result = fn.apply(this, args);
cache[argsToString] = result;
return result
}
}
}

const factorial = memoizedFunc((x) => {
if(x == 0) return 1;
else return x \* factorial(x-1)
})

console.log("Result is: ",factorial(5))
console.log("Result is: ",factorial(6))

16. Implement debouncing in JS
    const getData = () => {
    // Logic to fetch data.
    console.log('getData called');
    }
    const debounce = function(fn, delay){
    let timer;
    return function(){
    let context = this, arg = arguments;
    clearTimeout(timer);
    timer = setTimeOut(() => {
    getData.apply(context, args)
    }, delay);
    }
    }
    const betterGetData = debounce(getData, 300);
    <button>Get data</button>
    element.addEventListener("click", getData);
    element.addEventListener("click", betterGetData);

17. What is debounce?
    Time period between two consecutive request is 300ms from last called time.
    The new request will go after 300ms from last requested time.

18. Usecase for debouncing:
    search box suggestion
    Eliminate multiple clicks on a button

19. Throttling:
    Throttling is a technique in which, no matter how many times the user fires the event,
    the attached function will be executed only once in a given time interval.

const throttle = (func, limit) => {
let flag = true;
return function() {
let context = this, args = arguments;
if(flag){
func.apply(context, args);
flag = false;
setTimeout(() => {
flag = true;
}, limit)
}
}
}
const expensive = () => {console.log('expensive')}

const betterExpensive = throttle(expensive, 100);

Throttling: starttime + 300ms = newStartTime, all requests before newStartTime is ignored.
Debouncing: startTime = x, If you request within 300ms from x, let say at x+100ms.
newStartTime = x + 100ms + 300ms.
After the updated newStartTime, if user types agaain in input field, that will be answered.

            typing samsung phone in input field.

20. fetch('https://jsonplaceholder.typicode.com/todos/1')
    .then(response => response.json())
    .then(json => console.log(json))

21. Promises: https://github.com/Narahari-Sundaragopalan/JavaScript-Interview-Questions/blob/master/concepts/Promises.md

Simple Promise
const promise = new Promise(function(resolve, reject) {
resolve('Promise has been resolved!');
});

        promise.then((value) => console.log(value));
        console.log('I am not the promise');

Promise.all vs Promise.allSettled:
Promise.all:
If any one fails, Promise.all will fail.
Promise.allSettled:
Runs all array of promises passed in parallel.
return a promise, on resolving which we get array of results for all array of promises consumed.
Promise.race:
Returns the 1st promise that gets fulfilled or rejected.
Promise.any:
Only returns 1st fulfilled promise, ignores all rejected once.
